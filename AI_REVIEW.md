# ðŸ” Code Review - 11/8/2025, 6:43:07 PM

**Project:** AI Visual Code Review
**Generated by:** AI Visual Code Review v2.0

## ðŸ“Š Change Summary

```
AI_REVIEW.md                           | 545 ++++++++++++++++++++++++++++++++-
 src/js/core/StorageManager.js          | 202 ++++++++++++
 src/js/core/ThemeManager.js            | 254 +++++++++++++++
 tests/unit/core/StorageManager.test.js | 144 +++++++++
 tests/unit/core/ThemeManager.test.js   | 150 +++++++++
 5 files changed, 1279 insertions(+), 16 deletions(-)
```

## ðŸ“ Files Changed (5/5 selected)


### ðŸ“„ `AI_REVIEW.md`

**Type:** Documentation ðŸ“–

```diff
@@ -1,4 +1,4 @@
  1     -# ðŸ” Code Review - 11/8/2025, 6:23:18 PM
      1 +# ðŸ” Code Review - 11/8/2025, 6:29:25 PM
  2   2  
  3   3  **Project:** AI Visual Code Review
  4   4  **Generated by:** AI Visual Code Review v2.0
@@ -6,27 +6,540 @@
  6   6  ## ðŸ“Š Change Summary
  7   7  
  8   8  ```
  9     -package.json | 1 +
 10     - 1 file changed, 1 insertion(+)
      9 +src/js/services/MermaidService.js          | 121 ++++++++++++++++++++++++
     10 + src/js/services/PrismService.js            | 107 +++++++++++++++++++++
     11 + tests/unit/services/MermaidService.test.js | 105 +++++++++++++++++++++
     12 + tests/unit/services/PrismService.test.js   | 143 +++++++++++++++++++++++++++++
     13 + 4 files changed, 476 insertions(+)
 11  14  ```
 12  15  
 13     -## ðŸ“ Files Changed (1/1 selected)
     16 +## ðŸ“ Files Changed (4/4 selected)
 14  17  
 15  18  
 16     -### ðŸ“„ `package.json`
     19 +### âœ¨ `src/js/services/MermaidService.js` **[ADDED]**
 17  20  
 18     -**Type:** Configuration/Data File ðŸ“‹
     21 +**Status:** âœ… **NEW FILE** - This file has been newly created
     22 +
     23 +**Type:** JavaScript Source File ðŸŸ¨
 19  24  
 20  25  ```diff
 21     -@@ -30,6 +30,7 @@
 22     - 30  30    "devDependencies": {
 23     - 31  31      "@vitest/coverage-v8": "4.0.8",
 24     - 32  32      "@vitest/ui": "4.0.8",
 25     -     33 +    "ai-visual-code-review": "2.2.1",
 26     - 33  34      "eslint": "9.39.1",
 27     - 34  35      "jsdom": "27.1.0",
 28     - 35  36      "prettier": "3.6.2",
 29     - 36  37  
     26 +@@ -0,0 +1,121 @@
     27 +      1 +/**
     28 +      2 + * MermaidService - Mermaid Diagram Rendering Service
     29 +      3 + *
     30 +      4 + * Handles all Mermaid diagram rendering with theme-aware configuration.
     31 +      5 + * Isolated service for better testability and maintainability.
     32 +      6 + */
     33 +      7 +
     34 +      8 +import { MERMAID_CONFIG } from '../config/constants.js';
     35 +      9 +import { getCssVariable } from '../utils/colorHelpers.js';
     36 +     10 +
     37 +     11 +/**
     38 +     12 + * @class MermaidService
     39 +     13 + * @description Service for rendering Mermaid diagrams with theme integration
     40 +     14 + *
     41 +     15 + * @example
     42 +     16 + * const service = new MermaidService();
     43 +     17 + * service.initialize();
     44 +     18 + * const svg = await service.render('diagram-1', 'graph TD\n A-->B');
     45 +     19 + */
     46 +     20 +export class MermaidService {
     47 +     21 +  constructor() {
     48 +     22 +    this.initialized = false;
     49 +     23 +  }
     50 +     24 +
     51 +     25 +  /**
     52 +     26 +   * Initialize Mermaid with current theme colors
     53 +     27 +   * Extracts theme colors from CSS variables and configures Mermaid
     54 +     28 +   *
     55 +     29 +   * @returns {void}
     56 +     30 +   */
     57 +     31 +  initialize() {
     58 +     32 +    // Extract theme colors from CSS variables
     59 +     33 +    const h1Color = getCssVariable('--h1-color');
     60 +     34 +    const h2Color = getCssVariable('--h2-color');
     61 +     35 +    const h3Color = getCssVariable('--h3-color');
     62 +     36 +    const bgSecondary = getCssVariable('--bg-secondary');
     63 +     37 +    const textPrimary = getCssVariable('--text-primary');
     64 +     38 +
     65 +     39 +    // Configure Mermaid with theme colors
     66 +     40 +    if (typeof mermaid !== 'undefined') {
     67 +     41 +      mermaid.initialize({
     68 +     42 +        startOnLoad: MERMAID_CONFIG.START_ON_LOAD,
     69 +     43 +        theme: MERMAID_CONFIG.THEME,
     70 +     44 +        themeVariables: {
     71 +     45 +          primaryColor: bgSecondary,
     72 +     46 +          primaryTextColor: textPrimary,
     73 +     47 +          primaryBorderColor: h1Color,
     74 +     48 +          lineColor: h2Color,
     75 +     49 +          secondaryColor: bgSecondary,
     76 +     50 +          tertiaryColor: bgSecondary,
     77 +     51 +          background: bgSecondary,
     78 +     52 +          mainBkg: bgSecondary,
     79 +     53 +          secondBkg: bgSecondary,
     80 +     54 +          tertiaryBkg: bgSecondary,
     81 +     55 +          nodeBorder: h1Color,
     82 +     56 +          clusterBkg: bgSecondary,
     83 +     57 +          clusterBorder: h3Color,
     84 +     58 +          titleColor: textPrimary,
     85 +     59 +          edgeLabelBackground: bgSecondary,
     86 +     60 +          nodeTextColor: textPrimary,
     87 +     61 +          fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
     88 +     62 +        },
     89 +     63 +      });
     90 +     64 +
     91 +     65 +      this.initialized = true;
     92 +     66 +    } else {
     93 +     67 +      console.warn('Mermaid library not loaded');
     94 +     68 +    }
     95 +     69 +  }
     96 +     70 +
     97 +     71 +  /**
     98 +     72 +   * Render a Mermaid diagram
     99 +     73 +   *
    100 +     74 +   * @param {string} id - Unique ID for the diagram
    101 +     75 +   * @param {string} code - Mermaid diagram code
    102 +     76 +   * @returns {Promise<string>} Rendered SVG string
    103 +     77 +   * @throws {Error} If rendering fails
    104 +     78 +   *
    105 +     79 +   * @example
    106 +     80 +   * const svg = await service.render('diagram-1', 'graph TD\n A-->B');
    107 +     81 +   */
    108 +     82 +  async render(id, code) {
    109 +     83 +    // Initialize if not already done
    110 +     84 +    if (!this.initialized) {
    111 +     85 +      this.initialize();
    112 +     86 +    }
    113 +     87 +
    114 +     88 +    // Check if Mermaid is available
    115 +     89 +    if (typeof mermaid === 'undefined') {
    116 +     90 +      throw new Error('Mermaid library not loaded');
    117 +     91 +    }
    118 +     92 +
    119 +     93 +    try {
    120 +     94 +      const result = await mermaid.render(id, code);
    121 +     95 +      return result.svg;
    122 +     96 +    } catch (error) {
    123 +     97 +      console.error('Mermaid render error:', error);
    124 +     98 +      throw new Error(`Mermaid diagram error: ${error.message}`);
    125 +     99 +    }
    126 +    100 +  }
    127 +    101 +
    128 +    102 +  /**
    129 +    103 +   * Check if service is ready to render
    130 +    104 +   *
    131 +    105 +   * @returns {boolean} True if initialized
    132 +    106 +   */
    133 +    107 +  isReady() {
    134 +    108 +    return this.initialized && typeof mermaid !== 'undefined';
    135 +    109 +  }
    136 +    110 +
    137 +    111 +  /**
    138 +    112 +   * Reinitialize with new theme colors
    139 +    113 +   * Call this when theme changes
    140 +    114 +   *
    141 +    115 +   * @returns {void}
    142 +    116 +   */
    143 +    117 +  reinitialize() {
    144 +    118 +    this.initialized = false;
    145 +    119 +    this.initialize();
    146 +    120 +  }
    147 +    121 +}
    148 +    122  
    149 +
    150 +```
    151 +
    152 +
    153 +### âœ¨ `src/js/services/PrismService.js` **[ADDED]**
    154 +
    155 +**Status:** âœ… **NEW FILE** - This file has been newly created
    156 +
    157 +**Type:** JavaScript Source File ðŸŸ¨
    158 +
    159 +```diff
    160 +@@ -0,0 +1,107 @@
    161 +      1 +/**
    162 +      2 + * PrismService - Syntax Highlighting Service
    163 +      3 + *
    164 +      4 + * Handles all syntax highlighting using Prism.js.
    165 +      5 + * Isolated service for better testability and maintainability.
    166 +      6 + */
    167 +      7 +
    168 +      8 +/**
    169 +      9 + * @class PrismService
    170 +     10 + * @description Service for applying syntax highlighting to code blocks
    171 +     11 + *
    172 +     12 + * @example
    173 +     13 + * const service = new PrismService();
    174 +     14 + * service.highlightAll(previewElement);
    175 +     15 + */
    176 +     16 +export class PrismService {
    177 +     17 +  /**
    178 +     18 +   * Check if Prism library is loaded
    179 +     19 +   *
    180 +     20 +   * @returns {boolean} True if Prism is available
    181 +     21 +   * @private
    182 +     22 +   */
    183 +     23 +  isPrismLoaded() {
    184 +     24 +    return typeof Prism !== 'undefined';
    185 +     25 +  }
    186 +     26 +
    187 +     27 +  /**
    188 +     28 +   * Highlight all code blocks in container
    189 +     29 +   *
    190 +     30 +   * @param {HTMLElement} container - Container element with code blocks
    191 +     31 +   * @returns {number} Number of blocks highlighted
    192 +     32 +   *
    193 +     33 +   * @example
    194 +     34 +   * const count = service.highlightAll(document.getElementById('preview'));
    195 +     35 +   * console.log(`Highlighted ${count} code blocks`);
    196 +     36 +   */
    197 +     37 +  highlightAll(container) {
    198 +     38 +    if (!this.isPrismLoaded()) {
    199 +     39 +      console.warn('Prism library not loaded');
    200 +     40 +      return 0;
    201 +     41 +    }
    202 +     42 +
    203 +     43 +    const codeBlocks = container.querySelectorAll('pre code');
    204 +     44 +    let count = 0;
    205 +     45 +
    206 +     46 +    codeBlocks.forEach(block => {
    207 +     47 +      try {
    208 +     48 +        Prism.highlightElement(block);
    209 +     49 +        count++;
    210 +     50 +      } catch (error) {
    211 +     51 +        console.error('Prism highlight error:', error);
    212 +     52 +      }
    213 +     53 +    });
    214 +     54 +
    215 +     55 +    return count;
    216 +     56 +  }
    217 +     57 +
    218 +     58 +  /**
    219 +     59 +   * Highlight a single code block
    220 +     60 +   *
    221 +     61 +   * @param {HTMLElement} block - Code block element to highlight
    222 +     62 +   * @returns {boolean} True if successfully highlighted
    223 +     63 +   *
    224 +     64 +   * @example
    225 +     65 +   * const success = service.highlightElement(codeBlock);
    226 +     66 +   */
    227 +     67 +  highlightElement(block) {
    228 +     68 +    if (!this.isPrismLoaded()) {
    229 +     69 +      console.warn('Prism library not loaded');
    230 +     70 +      return false;
    231 +     71 +    }
    232 +     72 +
    233 +     73 +    try {
    234 +     74 +      Prism.highlightElement(block);
    235 +     75 +      return true;
    236 +     76 +    } catch (error) {
    237 +     77 +      console.error('Prism highlight error:', error);
    238 +     78 +      return false;
    239 +     79 +    }
    240 +     80 +  }
    241 +     81 +
    242 +     82 +  /**
    243 +     83 +   * Check if service is ready to highlight code
    244 +     84 +   *
    245 +     85 +   * @returns {boolean} True if Prism is loaded
    246 +     86 +   */
    247 +     87 +  isReady() {
    248 +     88 +    return this.isPrismLoaded();
    249 +     89 +  }
    250 +     90 +
    251 +     91 +  /**
    252 +     92 +   * Get list of supported languages
    253 +     93 +   *
    254 +     94 +   * @returns {string[]} Array of language keys
    255 +     95 +   *
    256 +     96 +   * @example
    257 +     97 +   * const languages = service.getSupportedLanguages();
    258 +     98 +   * // Returns: ['javascript', 'python', 'java', ...]
    259 +     99 +   */
    260 +    100 +  getSupportedLanguages() {
    261 +    101 +    if (!this.isPrismLoaded()) {
    262 +    102 +      return [];
    263 +    103 +    }
    264 +    104 +
    265 +    105 +    return Object.keys(Prism.languages || {});
    266 +    106 +  }
    267 +    107 +}
    268 +    108  
    269 +
    270 +```
    271 +
    272 +
    273 +### âœ¨ `tests/unit/services/MermaidService.test.js` **[ADDED]**
    274 +
    275 +**Status:** âœ… **NEW FILE** - This file has been newly created
    276 +
    277 +**Type:** JavaScript Source File ðŸŸ¨
    278 +
    279 +```diff
    280 +@@ -0,0 +1,105 @@
    281 +      1 +import { beforeEach, describe, expect, it, vi } from 'vitest';
    282 +      2 +import { MermaidService } from '../../../src/js/services/MermaidService.js';
    283 +      3 +
    284 +      4 +describe('MermaidService', () => {
    285 +      5 +  let service;
    286 +      6 +  let mockMermaid;
    287 +      7 +
    288 +      8 +  beforeEach(() => {
    289 +      9 +    service = new MermaidService();
    290 +     10 +
    291 +     11 +    // Mock global mermaid object
    292 +     12 +    mockMermaid = {
    293 +     13 +      initialize: vi.fn(),
    294 +     14 +      render: vi.fn().mockResolvedValue({ svg: '<svg>Test SVG</svg>' }),
    295 +     15 +    };
    296 +     16 +    global.mermaid = mockMermaid;
    297 +     17 +  });
    298 +     18 +
    299 +     19 +  describe('initialize', () => {
    300 +     20 +    it('should initialize Mermaid with theme colors', () => {
    301 +     21 +      service.initialize();
    302 +     22 +
    303 +     23 +      expect(mockMermaid.initialize).toHaveBeenCalledOnce();
    304 +     24 +      expect(service.initialized).toBe(true);
    305 +     25 +    });
    306 +     26 +
    307 +     27 +    it('should configure Mermaid with correct theme', () => {
    308 +     28 +      service.initialize();
    309 +     29 +
    310 +     30 +      const config = mockMermaid.initialize.mock.calls[0][0];
    311 +     31 +      expect(config.startOnLoad).toBe(false);
    312 +     32 +      expect(config.theme).toBe('base');
    313 +     33 +      expect(config.themeVariables).toBeDefined();
    314 +     34 +    });
    315 +     35 +
    316 +     36 +    it('should extract CSS colors for theme variables', () => {
    317 +     37 +      service.initialize();
    318 +     38 +
    319 +     39 +      const config = mockMermaid.initialize.mock.calls[0][0];
    320 +     40 +      expect(config.themeVariables.primaryBorderColor).toBeTruthy();
    321 +     41 +      expect(config.themeVariables.lineColor).toBeTruthy();
    322 +     42 +    });
    323 +     43 +  });
    324 +     44 +
    325 +     45 +  describe('render', () => {
    326 +     46 +    it('should render Mermaid diagram', async () => {
    327 +     47 +      const svg = await service.render('test-id', 'graph TD\n A-->B');
    328 +     48 +
    329 +     49 +      expect(svg).toContain('<svg>');
    330 +     50 +      expect(mockMermaid.render).toHaveBeenCalledWith('test-id', 'graph TD\n A-->B');
    331 +     51 +    });
    332 +     52 +
    333 +     53 +    it('should auto-initialize if not initialized', async () => {
    334 +     54 +      expect(service.initialized).toBe(false);
    335 +     55 +
    336 +     56 +      await service.render('test-id', 'graph TD\n A-->B');
    337 +     57 +
    338 +     58 +      expect(service.initialized).toBe(true);
    339 +     59 +    });
    340 +     60 +
    341 +     61 +    it('should handle render errors gracefully', async () => {
    342 +     62 +      mockMermaid.render.mockRejectedValue(new Error('Parse error'));
    343 +     63 +
    344 +     64 +      await expect(service.render('test-id', 'invalid')).rejects.toThrow(
    345 +     65 +        'Mermaid diagram error: Parse error'
    346 +     66 +      );
    347 +     67 +    });
    348 +     68 +
    349 +     69 +    it('should throw error if mermaid not loaded', async () => {
    350 +     70 +      global.mermaid = undefined;
    351 +     71 +      service.initialized = false;
    352 +     72 +
    353 +     73 +      await expect(service.render('test-id', 'graph TD\n A-->B')).rejects.toThrow(
    354 +     74 +        'Mermaid library not loaded'
    355 +     75 +      );
    356 +     76 +    });
    357 +     77 +  });
    358 +     78 +
    359 +     79 +  describe('isReady', () => {
    360 +     80 +    it('should return true when initialized and mermaid loaded', () => {
    361 +     81 +      service.initialize();
    362 +     82 +      expect(service.isReady()).toBe(true);
    363 +     83 +    });
    364 +     84 +
    365 +     85 +    it('should return false when not initialized', () => {
    366 +     86 +      expect(service.isReady()).toBe(false);
    367 +     87 +    });
    368 +     88 +
    369 +     89 +    it('should return false when mermaid not loaded', () => {
    370 +     90 +      global.mermaid = undefined;
    371 +     91 +      expect(service.isReady()).toBe(false);
    372 +     92 +    });
    373 +     93 +  });
    374 +     94 +
    375 +     95 +  describe('reinitialize', () => {
    376 +     96 +    it('should reset and reinitialize', () => {
    377 +     97 +      service.initialize();
    378 +     98 +      expect(service.initialized).toBe(true);
    379 +     99 +
    380 +    100 +      service.reinitialize();
    381 +    101 +
    382 +    102 +      expect(mockMermaid.initialize).toHaveBeenCalledTimes(2);
    383 +    103 +    });
    384 +    104 +  });
    385 +    105 +});
    386 +    106  
    387 +
    388 +```
    389 +
    390 +
    391 +### âœ¨ `tests/unit/services/PrismService.test.js` **[ADDED]**
    392 +
    393 +**Status:** âœ… **NEW FILE** - This file has been newly created
    394 +
    395 +**Type:** JavaScript Source File ðŸŸ¨
    396 +
    397 +```diff
    398 +@@ -0,0 +1,143 @@
    399 +      1 +import { beforeEach, describe, expect, it, vi } from 'vitest';
    400 +      2 +import { PrismService } from '../../../src/js/services/PrismService.js';
    401 +      3 +
    402 +      4 +describe('PrismService', () => {
    403 +      5 +  let service;
    404 +      6 +  let mockPrism;
    405 +      7 +  let mockContainer;
    406 +      8 +  let mockCodeBlock;
    407 +      9 +
    408 +     10 +  beforeEach(() => {
    409 +     11 +    service = new PrismService();
    410 +     12 +
    411 +     13 +    // Mock Prism object
    412 +     14 +    mockPrism = {
    413 +     15 +      highlightElement: vi.fn(),
    414 +     16 +      languages: {
    415 +     17 +        javascript: {},
    416 +     18 +        python: {},
    417 +     19 +        java: {},
    418 +     20 +      },
    419 +     21 +    };
    420 +     22 +    global.Prism = mockPrism;
    421 +     23 +
    422 +     24 +    // Mock DOM elements
    423 +     25 +    mockCodeBlock = document.createElement('code');
    424 +     26 +    mockContainer = document.createElement('div');
    425 +     27 +    const pre = document.createElement('pre');
    426 +     28 +    pre.appendChild(mockCodeBlock);
    427 +     29 +    mockContainer.appendChild(pre);
    428 +     30 +  });
    429 +     31 +
    430 +     32 +  describe('highlightAll', () => {
    431 +     33 +    it('should highlight all code blocks in container', () => {
    432 +     34 +      const count = service.highlightAll(mockContainer);
    433 +     35 +
    434 +     36 +      expect(count).toBe(1);
    435 +     37 +      expect(mockPrism.highlightElement).toHaveBeenCalledOnce();
    436 +     38 +      expect(mockPrism.highlightElement).toHaveBeenCalledWith(mockCodeBlock);
    437 +     39 +    });
    438 +     40 +
    439 +     41 +    it('should return 0 if Prism not loaded', () => {
    440 +     42 +      global.Prism = undefined;
    441 +     43 +
    442 +     44 +      const count = service.highlightAll(mockContainer);
    443 +     45 +
    444 +     46 +      expect(count).toBe(0);
    445 +     47 +    });
    446 +     48 +
    447 +     49 +    it('should handle multiple code blocks', () => {
    448 +     50 +      // Add more code blocks
    449 +     51 +      for (let i = 0; i < 3; i++) {
    450 +     52 +        const pre = document.createElement('pre');
    451 +     53 +        const code = document.createElement('code');
    452 +     54 +        pre.appendChild(code);
    453 +     55 +        mockContainer.appendChild(pre);
    454 +     56 +      }
    455 +     57 +
    456 +     58 +      const count = service.highlightAll(mockContainer);
    457 +     59 +
    458 +     60 +      expect(count).toBe(4); // 1 original + 3 added
    459 +     61 +      expect(mockPrism.highlightElement).toHaveBeenCalledTimes(4);
    460 +     62 +    });
    461 +     63 +
    462 +     64 +    it('should continue if one block fails', () => {
    463 +     65 +      // Add another block
    464 +     66 +      const pre = document.createElement('pre');
    465 +     67 +      const code = document.createElement('code');
    466 +     68 +      pre.appendChild(code);
    467 +     69 +      mockContainer.appendChild(pre);
    468 +     70 +
    469 +     71 +      // Make first call fail
    470 +     72 +      mockPrism.highlightElement.mockImplementationOnce(() => {
    471 +     73 +        throw new Error('Highlight failed');
    472 +     74 +      });
    473 +     75 +
    474 +     76 +      const count = service.highlightAll(mockContainer);
    475 +     77 +
    476 +     78 +      expect(count).toBe(1); // Only second block succeeded
    477 +     79 +    });
    478 +     80 +  });
    479 +     81 +
    480 +     82 +  describe('highlightElement', () => {
    481 +     83 +    it('should highlight single code block', () => {
    482 +     84 +      const success = service.highlightElement(mockCodeBlock);
    483 +     85 +
    484 +     86 +      expect(success).toBe(true);
    485 +     87 +      expect(mockPrism.highlightElement).toHaveBeenCalledWith(mockCodeBlock);
    486 +     88 +    });
    487 +     89 +
    488 +     90 +    it('should return false if Prism not loaded', () => {
    489 +     91 +      global.Prism = undefined;
    490 +     92 +
    491 +     93 +      const success = service.highlightElement(mockCodeBlock);
    492 +     94 +
    493 +     95 +      expect(success).toBe(false);
    494 +     96 +    });
    495 +     97 +
    496 +     98 +    it('should return false on error', () => {
    497 +     99 +      mockPrism.highlightElement.mockImplementation(() => {
    498 +    100 +        throw new Error('Highlight failed');
    499 +    101 +      });
    500 +    102 +
    501 +    103 +      const success = service.highlightElement(mockCodeBlock);
    502 +    104 +
    503 +    105 +      expect(success).toBe(false);
    504 +    106 +    });
    505 +    107 +  });
    506 +    108 +
    507 +    109 +  describe('isReady', () => {
    508 +    110 +    it('should return true when Prism is loaded', () => {
    509 +    111 +      expect(service.isReady()).toBe(true);
    510 +    112 +    });
    511 +    113 +
    512 +    114 +    it('should return false when Prism not loaded', () => {
    513 +    115 +      global.Prism = undefined;
    514 +    116 +      expect(service.isReady()).toBe(false);
    515 +    117 +    });
    516 +    118 +  });
    517 +    119 +
    518 +    120 +  describe('getSupportedLanguages', () => {
    519 +    121 +    it('should return list of supported languages', () => {
    520 +    122 +      const languages = service.getSupportedLanguages();
    521 +    123 +
    522 +    124 +      expect(languages).toEqual(['javascript', 'python', 'java']);
    523 +    125 +    });
    524 +    126 +
    525 +    127 +    it('should return empty array if Prism not loaded', () => {
    526 +    128 +      global.Prism = undefined;
    527 +    129 +
    528 +    130 +      const languages = service.getSupportedLanguages();
    529 +    131 +
    530 +    132 +      expect(languages).toEqual([]);
    531 +    133 +    });
    532 +    134 +
    533 +    135 +    it('should handle missing languages object', () => {
    534 +    136 +      global.Prism = {};
    535 +    137 +
    536 +    138 +      const languages = service.getSupportedLanguages();
    537 +    139 +
    538 +    140 +      expect(languages).toEqual([]);
    539 +    141 +    });
    540 +    142 +  });
    541 +    143 +});
    542 +    144  
 30 543  
 31 544  ```
 32 545  
@@ -72,4 +585,4 @@ Please provide specific feedback on:
 72 585  
 73 586  ---
 74 587  *Generated by AI Visual Code Review v2.0 - Unified Export Script*
 75     -*Files processed: 1/1 | Errors: 0 | Generated: 2025-11-08T12:53:18.378Z*
    588 +*Files processed: 4/4 | Errors: 0 | Generated: 2025-11-08T12:59:25.939Z*
 76 589  

```


### âœ¨ `src/js/core/StorageManager.js` **[ADDED]**

**Status:** âœ… **NEW FILE** - This file has been newly created

**Type:** JavaScript Source File ðŸŸ¨

```diff
@@ -0,0 +1,202 @@
      1 +/**
      2 + * StorageManager - LocalStorage Abstraction Layer
      3 + *
      4 + * Provides a clean interface for localStorage operations with error handling.
      5 + * Centralizes all data persistence logic for better testability.
      6 + */
      7 +
      8 +/**
      9 + * @class StorageManager
     10 + * @description Manages all localStorage operations with error handling
     11 + *
     12 + * @example
     13 + * const storage = new StorageManager();
     14 + * storage.set(STORAGE_KEYS.MARKDOWN_CONTENT, 'Hello World');
     15 + * const content = storage.get(STORAGE_KEYS.MARKDOWN_CONTENT);
     16 + */
     17 +export class StorageManager {
     18 +  constructor() {
     19 +    this.CURRENT_VERSION = 2;
     20 +    this.VERSION_KEY = '__storage_version';
     21 +  }
     22 +
     23 +  /**
     24 +   * Get item from localStorage
     25 +   *
     26 +   * @param {string} key - Storage key
     27 +   * @returns {string|null} Stored value or null if not found
     28 +   *
     29 +   * @example
     30 +   * const theme = storage.get(STORAGE_KEYS.SELECTED_THEME);
     31 +   */
     32 +  get(key) {
     33 +    try {
     34 +      return localStorage.getItem(key);
     35 +    } catch (error) {
     36 +      console.error('Storage get error:', error);
     37 +      return null;
     38 +    }
     39 +  }
     40 +
     41 +  /**
     42 +   * Set item in localStorage
     43 +   *
     44 +   * @param {string} key - Storage key
     45 +   * @param {string} value - Value to store
     46 +   * @returns {boolean} True if successful
     47 +   *
     48 +   * @example
     49 +   * storage.set(STORAGE_KEYS.SELECTED_THEME, 'ocean-dark');
     50 +   */
     51 +  set(key, value) {
     52 +    try {
     53 +      localStorage.setItem(key, value);
     54 +      return true;
     55 +    } catch (error) {
     56 +      console.error('Storage set error:', error);
     57 +      return false;
     58 +    }
     59 +  }
     60 +
     61 +  /**
     62 +   * Remove item from localStorage
     63 +   *
     64 +   * @param {string} key - Storage key
     65 +   * @returns {boolean} True if successful
     66 +   *
     67 +   * @example
     68 +   * storage.remove(STORAGE_KEYS.CUSTOM_THEME);
     69 +   */
     70 +  remove(key) {
     71 +    try {
     72 +      localStorage.removeItem(key);
     73 +      return true;
     74 +    } catch (error) {
     75 +      console.error('Storage remove error:', error);
     76 +      return false;
     77 +    }
     78 +  }
     79 +
     80 +  /**
     81 +   * Check if key exists in storage
     82 +   *
     83 +   * @param {string} key - Storage key
     84 +   * @returns {boolean} True if key exists
     85 +   *
     86 +   * @example
     87 +   * if (storage.has(STORAGE_KEYS.CUSTOM_THEME)) { }
     88 +   */
     89 +  has(key) {
     90 +    return this.get(key) !== null;
     91 +  }
     92 +
     93 +  /**
     94 +   * Get JSON object from storage
     95 +   *
     96 +   * @param {string} key - Storage key
     97 +   * @returns {any|null} Parsed JSON or null if not found/invalid
     98 +   *
     99 +   * @example
    100 +   * const theme = storage.getJSON(STORAGE_KEYS.CUSTOM_THEME);
    101 +   */
    102 +  getJSON(key) {
    103 +    const value = this.get(key);
    104 +    if (!value) {
    105 +      return null;
    106 +    }
    107 +
    108 +    try {
    109 +      return JSON.parse(value);
    110 +    } catch (error) {
    111 +      console.error('JSON parse error:', error);
    112 +      return null;
    113 +    }
    114 +  }
    115 +
    116 +  /**
    117 +   * Set JSON object in storage
    118 +   *
    119 +   * @param {string} key - Storage key
    120 +   * @param {any} value - Value to stringify and store
    121 +   * @returns {boolean} True if successful
    122 +   *
    123 +   * @example
    124 +   * storage.setJSON(STORAGE_KEYS.CUSTOM_THEME, { '--h1-color': '#ff0000' });
    125 +   */
    126 +  setJSON(key, value) {
    127 +    try {
    128 +      const json = JSON.stringify(value);
    129 +      return this.set(key, json);
    130 +    } catch (error) {
    131 +      console.error('JSON stringify error:', error);
    132 +      return false;
    133 +    }
    134 +  }
    135 +
    136 +  /**
    137 +   * Clear all items from storage
    138 +   * USE WITH CAUTION
    139 +   *
    140 +   * @returns {boolean} True if successful
    141 +   */
    142 +  clear() {
    143 +    try {
    144 +      localStorage.clear();
    145 +      return true;
    146 +    } catch (error) {
    147 +      console.error('Storage clear error:', error);
    148 +      return false;
    149 +    }
    150 +  }
    151 +
    152 +  /**
    153 +   * Get all keys in storage
    154 +   *
    155 +   * @returns {string[]} Array of storage keys
    156 +   */
    157 +  getAllKeys() {
    158 +    try {
    159 +      return Object.keys(localStorage);
    160 +    } catch (error) {
    161 +      console.error('Storage getAllKeys error:', error);
    162 +      return [];
    163 +    }
    164 +  }
    165 +
    166 +  /**
    167 +   * Get storage size in bytes (approximate)
    168 +   *
    169 +   * @returns {number} Approximate size in bytes
    170 +   */
    171 +  getSize() {
    172 +    try {
    173 +      let total = 0;
    174 +      for (const key in localStorage) {
    175 +        if (localStorage.hasOwnProperty(key)) {
    176 +          const value = localStorage.getItem(key);
    177 +          total += key.length + (value?.length || 0);
    178 +        }
    179 +      }
    180 +      return total;
    181 +    } catch (error) {
    182 +      console.error('Storage getSize error:', error);
    183 +      return 0;
    184 +    }
    185 +  }
    186 +
    187 +  /**
    188 +   * Check if storage is available
    189 +   *
    190 +   * @returns {boolean} True if localStorage is available
    191 +   */
    192 +  isAvailable() {
    193 +    try {
    194 +      const test = '__storage_test__';
    195 +      localStorage.setItem(test, test);
    196 +      localStorage.removeItem(test);
    197 +      return true;
    198 +    } catch (error) {
    199 +      return false;
    200 +    }
    201 +  }
    202 +}
    203  

```


### âœ¨ `src/js/core/ThemeManager.js` **[ADDED]**

**Status:** âœ… **NEW FILE** - This file has been newly created

**Type:** JavaScript Source File ðŸŸ¨

```diff
@@ -0,0 +1,254 @@
      1 +/**
      2 + * ThemeManager - Theme Management Core Module
      3 + *
      4 + * Handles all theme operations: loading, switching, customization, and persistence.
      5 + * Integrates with StorageManager for persistence and MermaidService for theme updates.
      6 + */
      7 +
      8 +import { ELEMENT_IDS, STORAGE_KEYS, THEMES } from '../config/constants.js';
      9 +import { getCssVariable, removeCssVariable, setCssVariable } from '../utils/colorHelpers.js';
     10 +import { isValidTheme } from '../utils/validators.js';
     11 +
     12 +/**
     13 + * @class ThemeManager
     14 + * @description Manages theme loading, switching, and customization
     15 + *
     16 + * @example
     17 + * const storage = new StorageManager();
     18 + * const themeManager = new ThemeManager(storage);
     19 + * await themeManager.loadTheme('ocean-dark');
     20 + */
     21 +export class ThemeManager {
     22 +  /**
     23 +   * @param {StorageManager} storageManager - Storage manager instance
     24 +   */
     25 +  constructor(storageManager) {
     26 +    this.storage = storageManager;
     27 +    this.currentTheme = null;
     28 +    this.onThemeChange = null;
     29 +  }
     30 +
     31 +  /**
     32 +   * Load and apply a theme
     33 +   *
     34 +   * @param {string} themeName - Name of theme to load
     35 +   * @returns {Promise<boolean>} True if successful
     36 +   * @throws {Error} If theme name is invalid
     37 +   *
     38 +   * @example
     39 +   * await themeManager.loadTheme('obsidian-dark');
     40 +   */
     41 +  async loadTheme(themeName) {
     42 +    // Validate theme name
     43 +    if (!isValidTheme(themeName)) {
     44 +      throw new Error(`Invalid theme: ${themeName}`);
     45 +    }
     46 +
     47 +    // Load appropriate theme
     48 +    if (themeName === THEMES.CUSTOM) {
     49 +      return this.loadCustomTheme();
     50 +    }
     51 +
     52 +    return this.loadBuiltInTheme(themeName);
     53 +  }
     54 +
     55 +  /**
     56 +   * Load a built-in theme from CSS file
     57 +   *
     58 +   * @param {string} themeName - Built-in theme name
     59 +   * @returns {Promise<boolean>} True if successful
     60 +   * @private
     61 +   */
     62 +  async loadBuiltInTheme(themeName) {
     63 +    try {
     64 +      // Clear any custom inline styles
     65 +      this.clearInlineStyles();
     66 +
     67 +      // Load theme stylesheet
     68 +      const stylesheet = document.getElementById(ELEMENT_IDS.THEME_STYLESHEET);
     69 +      if (!stylesheet) {
     70 +        throw new Error('Theme stylesheet element not found');
     71 +      }
     72 +
     73 +      stylesheet.href = `themes/${themeName}.css`;
     74 +
     75 +      // Save selection
     76 +      this.currentTheme = themeName;
     77 +      this.storage.set(STORAGE_KEYS.SELECTED_THEME, themeName);
     78 +
     79 +      // Notify listeners
     80 +      this.notifyThemeChange(themeName);
     81 +
     82 +      return true;
     83 +    } catch (error) {
     84 +      console.error('Failed to load built-in theme:', error);
     85 +      return false;
     86 +    }
     87 +  }
     88 +
     89 +  /**
     90 +   * Load custom theme from storage
     91 +   *
     92 +   * @returns {Promise<boolean>} True if successful
     93 +   * @private
     94 +   */
     95 +  async loadCustomTheme() {
     96 +    const customTheme = this.storage.getJSON(STORAGE_KEYS.CUSTOM_THEME);
     97 +
     98 +    if (!customTheme) {
     99 +      console.warn('No custom theme found, loading default');
    100 +      return this.loadTheme(THEMES.DEFAULT_LIGHT);
    101 +    }
    102 +
    103 +    try {
    104 +      // Apply custom colors
    105 +      Object.entries(customTheme).forEach(([property, value]) => {
    106 +        setCssVariable(property, value);
    107 +      });
    108 +
    109 +      this.currentTheme = THEMES.CUSTOM;
    110 +      this.storage.set(STORAGE_KEYS.SELECTED_THEME, THEMES.CUSTOM);
    111 +
    112 +      // Notify listeners
    113 +      this.notifyThemeChange(THEMES.CUSTOM);
    114 +
    115 +      return true;
    116 +    } catch (error) {
    117 +      console.error('Failed to load custom theme:', error);
    118 +      return false;
    119 +    }
    120 +  }
    121 +
    122 +  /**
    123 +   * Save custom theme colors
    124 +   *
    125 +   * @param {Object} colors - Object with CSS variable names as keys
    126 +   * @returns {boolean} True if successful
    127 +   *
    128 +   * @example
    129 +   * themeManager.saveCustomTheme({ '--h1-color': '#ff0000' });
    130 +   */
    131 +  saveCustomTheme(colors) {
    132 +    if (!colors || typeof colors !== 'object') {
    133 +      console.error('Invalid colors object');
    134 +      return false;
    135 +    }
    136 +
    137 +    return this.storage.setJSON(STORAGE_KEYS.CUSTOM_THEME, colors);
    138 +  }
    139 +
    140 +  /**
    141 +   * Get current theme name
    142 +   *
    143 +   * @returns {string|null} Current theme name
    144 +   */
    145 +  getCurrentTheme() {
    146 +    return this.currentTheme;
    147 +  }
    148 +
    149 +  /**
    150 +   * Get all current theme colors
    151 +   *
    152 +   * @returns {Object} Object with CSS variable names and values
    153 +   *
    154 +   * @example
    155 +   * const colors = themeManager.getCurrentColors();
    156 +   * // { '--bg-primary': '#ffffff', '--h1-color': '#0969da', ... }
    157 +   */
    158 +  getCurrentColors() {
    159 +    const colors = {};
    160 +    const style = getComputedStyle(document.documentElement);
    161 +
    162 +    // Extract all theme-related CSS variables
    163 +    const cssVarNames = [
    164 +      '--bg-primary',
    165 +      '--bg-secondary',
    166 +      '--bg-tertiary',
    167 +      '--text-primary',
    168 +      '--text-secondary',
    169 +      '--h1-color',
    170 +      '--h2-color',
    171 +      '--h3-color',
    172 +      '--h4-color',
    173 +      '--h5-color',
    174 +      '--h6-color',
    175 +      '--link-color',
    176 +      '--bold-color',
    177 +      '--italic-color',
    178 +      '--code-text',
    179 +      '--code-bg',
    180 +      '--code-block-bg',
    181 +      '--blockquote-border',
    182 +    ];
    183 +
    184 +    cssVarNames.forEach(varName => {
    185 +      colors[varName] = getCssVariable(varName);
    186 +    });
    187 +
    188 +    return colors;
    189 +  }
    190 +
    191 +  /**
    192 +   * Clear all inline CSS variable overrides
    193 +   * Used when switching from custom to built-in theme
    194 +   *
    195 +   * @private
    196 +   */
    197 +  clearInlineStyles() {
    198 +    const root = document.documentElement;
    199 +    const styles = root.style;
    200 +
    201 +    for (let i = styles.length - 1; i >= 0; i--) {
    202 +      const prop = styles[i];
    203 +      if (prop.startsWith('--')) {
    204 +        removeCssVariable(prop);
    205 +      }
    206 +    }
    207 +  }
    208 +
    209 +  /**
    210 +   * Register callback for theme changes
    211 +   *
    212 +   * @param {Function} callback - Function to call when theme changes
    213 +   *
    214 +   * @example
    215 +   * themeManager.onThemeChange = (themeName) => {
    216 +   *   console.log('Theme changed to:', themeName);
    217 +   *   mermaidService.reinitialize();
    218 +   * };
    219 +   */
    220 +  setThemeChangeListener(callback) {
    221 +    this.onThemeChange = callback;
    222 +  }
    223 +
    224 +  /**
    225 +   * Notify listeners of theme change
    226 +   *
    227 +   * @param {string} themeName - New theme name
    228 +   * @private
    229 +   */
    230 +  notifyThemeChange(themeName) {
    231 +    if (this.onThemeChange && typeof this.onThemeChange === 'function') {
    232 +      this.onThemeChange(themeName);
    233 +    }
    234 +  }
    235 +
    236 +  /**
    237 +   * Get list of all available themes
    238 +   *
    239 +   * @returns {string[]} Array of theme names
    240 +   */
    241 +  getAvailableThemes() {
    242 +    return Object.values(THEMES);
    243 +  }
    244 +
    245 +  /**
    246 +   * Check if a theme exists
    247 +   *
    248 +   * @param {string} themeName - Theme name to check
    249 +   * @returns {boolean} True if theme exists
    250 +   */
    251 +  themeExists(themeName) {
    252 +    return isValidTheme(themeName);
    253 +  }
    254 +}
    255  

```


### âœ¨ `tests/unit/core/StorageManager.test.js` **[ADDED]**

**Status:** âœ… **NEW FILE** - This file has been newly created

**Type:** JavaScript Source File ðŸŸ¨

```diff
@@ -0,0 +1,144 @@
      1 +import { beforeEach, describe, expect, it } from 'vitest';
      2 +import { StorageManager } from '../../../src/js/core/StorageManager.js';
      3 +
      4 +describe('StorageManager', () => {
      5 +  let storage;
      6 +
      7 +  beforeEach(() => {
      8 +    storage = new StorageManager();
      9 +    localStorage.clear();
     10 +  });
     11 +
     12 +  describe('get/set', () => {
     13 +    it('should store and retrieve string values', () => {
     14 +      storage.set('test-key', 'test-value');
     15 +      expect(storage.get('test-key')).toBe('test-value');
     16 +    });
     17 +
     18 +    it('should return null for non-existent key', () => {
     19 +      expect(storage.get('non-existent')).toBeNull();
     20 +    });
     21 +
     22 +    it('should return true on successful set', () => {
     23 +      const result = storage.set('key', 'value');
     24 +      expect(result).toBe(true);
     25 +    });
     26 +  });
     27 +
     28 +  describe('getJSON/setJSON', () => {
     29 +    it('should store and retrieve JSON objects', () => {
     30 +      const obj = { name: 'test', value: 123 };
     31 +      storage.setJSON('json-key', obj);
     32 +
     33 +      const retrieved = storage.getJSON('json-key');
     34 +      expect(retrieved).toEqual(obj);
     35 +    });
     36 +
     37 +    it('should return null for non-existent JSON key', () => {
     38 +      expect(storage.getJSON('non-existent')).toBeNull();
     39 +    });
     40 +
     41 +    it('should handle complex nested objects', () => {
     42 +      const complex = {
     43 +        theme: 'dark',
     44 +        colors: {
     45 +          primary: '#000',
     46 +          secondary: '#fff',
     47 +        },
     48 +        settings: [1, 2, 3],
     49 +      };
     50 +
     51 +      storage.setJSON('complex', complex);
     52 +      expect(storage.getJSON('complex')).toEqual(complex);
     53 +    });
     54 +
     55 +    it('should return null for invalid JSON', () => {
     56 +      localStorage.setItem('invalid-json', '{invalid}');
     57 +      expect(storage.getJSON('invalid-json')).toBeNull();
     58 +    });
     59 +  });
     60 +
     61 +  describe('remove', () => {
     62 +    it('should remove item from storage', () => {
     63 +      storage.set('remove-test', 'value');
     64 +      expect(storage.has('remove-test')).toBe(true);
     65 +
     66 +      storage.remove('remove-test');
     67 +      expect(storage.has('remove-test')).toBe(false);
     68 +    });
     69 +
     70 +    it('should return true on successful removal', () => {
     71 +      storage.set('test', 'value');
     72 +      const result = storage.remove('test');
     73 +      expect(result).toBe(true);
     74 +    });
     75 +  });
     76 +
     77 +  describe('has', () => {
     78 +    it('should return true for existing keys', () => {
     79 +      storage.set('exists', 'value');
     80 +      expect(storage.has('exists')).toBe(true);
     81 +    });
     82 +
     83 +    it('should return false for non-existent keys', () => {
     84 +      expect(storage.has('does-not-exist')).toBe(false);
     85 +    });
     86 +  });
     87 +
     88 +  describe('clear', () => {
     89 +    it('should remove all items', () => {
     90 +      storage.set('key1', 'value1');
     91 +      storage.set('key2', 'value2');
     92 +
     93 +      storage.clear();
     94 +
     95 +      expect(storage.has('key1')).toBe(false);
     96 +      expect(storage.has('key2')).toBe(false);
     97 +    });
     98 +
     99 +    it('should return true on success', () => {
    100 +      const result = storage.clear();
    101 +      expect(result).toBe(true);
    102 +    });
    103 +  });
    104 +
    105 +  describe('getAllKeys', () => {
    106 +    it('should return all storage keys', () => {
    107 +      storage.set('key1', 'value1');
    108 +      storage.set('key2', 'value2');
    109 +
    110 +      const keys = storage.getAllKeys();
    111 +      // In test environment, check that method returns an array
    112 +      expect(Array.isArray(keys)).toBe(true);
    113 +      expect(keys.length).toBeGreaterThanOrEqual(2);
    114 +    });
    115 +
    116 +    it('should return empty array when storage is empty', () => {
    117 +      storage.clear();
    118 +      const keys = storage.getAllKeys();
    119 +      expect(Array.isArray(keys)).toBe(true);
    120 +    });
    121 +  });
    122 +
    123 +  describe('getSize', () => {
    124 +    it('should calculate approximate storage size', () => {
    125 +      storage.set('test', 'value');
    126 +      const size = storage.getSize();
    127 +
    128 +      expect(size).toBeGreaterThan(0);
    129 +      expect(typeof size).toBe('number');
    130 +    });
    131 +
    132 +    it('should return 0 for empty storage', () => {
    133 +      storage.clear();
    134 +      const size = storage.getSize();
    135 +      expect(size).toBeGreaterThanOrEqual(0);
    136 +    });
    137 +  });
    138 +
    139 +  describe('isAvailable', () => {
    140 +    it('should return true when localStorage is available', () => {
    141 +      expect(storage.isAvailable()).toBe(true);
    142 +    });
    143 +  });
    144 +});
    145  

```


### âœ¨ `tests/unit/core/ThemeManager.test.js` **[ADDED]**

**Status:** âœ… **NEW FILE** - This file has been newly created

**Type:** JavaScript Source File ðŸŸ¨

```diff
@@ -0,0 +1,150 @@
      1 +import { beforeEach, describe, expect, it, vi } from 'vitest';
      2 +import { ThemeManager } from '../../../src/js/core/ThemeManager.js';
      3 +
      4 +describe('ThemeManager', () => {
      5 +  let themeManager;
      6 +  let mockStorage;
      7 +  let mockStylesheet;
      8 +
      9 +  beforeEach(() => {
     10 +    // Mock StorageManager
     11 +    mockStorage = {
     12 +      get: vi.fn(),
     13 +      set: vi.fn().mockReturnValue(true),
     14 +      getJSON: vi.fn(),
     15 +      setJSON: vi.fn().mockReturnValue(true),
     16 +    };
     17 +
     18 +    // Mock theme stylesheet element
     19 +    mockStylesheet = { href: '' };
     20 +    vi.spyOn(document, 'getElementById').mockReturnValue(mockStylesheet);
     21 +
     22 +    themeManager = new ThemeManager(mockStorage);
     23 +  });
     24 +
     25 +  describe('loadTheme', () => {
     26 +    it('should load built-in theme successfully', async () => {
     27 +      const result = await themeManager.loadTheme('ocean-dark');
     28 +
     29 +      expect(result).toBe(true);
     30 +      expect(mockStorage.set).toHaveBeenCalledWith('selectedTheme', 'ocean-dark');
     31 +      expect(mockStylesheet.href).toContain('ocean-dark');
     32 +    });
     33 +
     34 +    it('should throw error for invalid theme', async () => {
     35 +      await expect(themeManager.loadTheme('invalid-theme')).rejects.toThrow('Invalid theme');
     36 +    });
     37 +
     38 +    it('should load custom theme when specified', async () => {
     39 +      const customColors = { '--h1-color': '#ff0000' };
     40 +      mockStorage.getJSON.mockReturnValue(customColors);
     41 +
     42 +      const result = await themeManager.loadTheme('custom');
     43 +
     44 +      expect(result).toBe(true);
     45 +      expect(mockStorage.getJSON).toHaveBeenCalledWith('customTheme');
     46 +    });
     47 +
     48 +    it('should fallback to default if custom theme not found', async () => {
     49 +      mockStorage.getJSON.mockReturnValue(null);
     50 +
     51 +      const result = await themeManager.loadTheme('custom');
     52 +
     53 +      expect(mockStylesheet.href).toContain('default-light');
     54 +    });
     55 +  });
     56 +
     57 +  describe('saveCustomTheme', () => {
     58 +    it('should save custom theme colors', () => {
     59 +      const colors = { '--h1-color': '#00ff00' };
     60 +
     61 +      const result = themeManager.saveCustomTheme(colors);
     62 +
     63 +      expect(result).toBe(true);
     64 +      expect(mockStorage.setJSON).toHaveBeenCalledWith('customTheme', colors);
     65 +    });
     66 +
     67 +    it('should reject invalid colors object', () => {
     68 +      const result = themeManager.saveCustomTheme(null);
     69 +
     70 +      expect(result).toBe(false);
     71 +      expect(mockStorage.setJSON).not.toHaveBeenCalled();
     72 +    });
     73 +
     74 +    it('should reject non-object colors', () => {
     75 +      const result = themeManager.saveCustomTheme('not-an-object');
     76 +
     77 +      expect(result).toBe(false);
     78 +    });
     79 +  });
     80 +
     81 +  describe('getCurrentTheme', () => {
     82 +    it('should return current theme name', async () => {
     83 +      await themeManager.loadTheme('neon-dark');
     84 +
     85 +      expect(themeManager.getCurrentTheme()).toBe('neon-dark');
     86 +    });
     87 +
     88 +    it('should return null initially', () => {
     89 +      expect(themeManager.getCurrentTheme()).toBeNull();
     90 +    });
     91 +  });
     92 +
     93 +  describe('getCurrentColors', () => {
     94 +    it('should extract all current CSS variables', () => {
     95 +      const colors = themeManager.getCurrentColors();
     96 +
     97 +      expect(colors).toHaveProperty('--bg-primary');
     98 +      expect(colors).toHaveProperty('--h1-color');
     99 +      expect(colors).toHaveProperty('--text-primary');
    100 +    });
    101 +
    102 +    it('should return object with color values', () => {
    103 +      const colors = themeManager.getCurrentColors();
    104 +
    105 +      expect(typeof colors).toBe('object');
    106 +      expect(Object.keys(colors).length).toBeGreaterThan(0);
    107 +    });
    108 +  });
    109 +
    110 +  describe('setThemeChangeListener', () => {
    111 +    it('should register theme change callback', async () => {
    112 +      const callback = vi.fn();
    113 +      themeManager.setThemeChangeListener(callback);
    114 +
    115 +      await themeManager.loadTheme('forest-dark');
    116 +
    117 +      expect(callback).toHaveBeenCalledWith('forest-dark');
    118 +    });
    119 +
    120 +    it('should not throw if callback is null', async () => {
    121 +      themeManager.setThemeChangeListener(null);
    122 +
    123 +      await expect(themeManager.loadTheme('ocean-light')).resolves.toBe(true);
    124 +    });
    125 +  });
    126 +
    127 +  describe('getAvailableThemes', () => {
    128 +    it('should return list of all themes', () => {
    129 +      const themes = themeManager.getAvailableThemes();
    130 +
    131 +      expect(themes).toContain('default-light');
    132 +      expect(themes).toContain('ocean-dark');
    133 +      expect(themes).toContain('obsidian-dark');
    134 +      expect(themes).toContain('custom');
    135 +      expect(themes.length).toBe(13);
    136 +    });
    137 +  });
    138 +
    139 +  describe('themeExists', () => {
    140 +    it('should return true for valid themes', () => {
    141 +      expect(themeManager.themeExists('default-dark')).toBe(true);
    142 +      expect(themeManager.themeExists('obsidian-light')).toBe(true);
    143 +    });
    144 +
    145 +    it('should return false for invalid themes', () => {
    146 +      expect(themeManager.themeExists('invalid')).toBe(false);
    147 +      expect(themeManager.themeExists('')).toBe(false);
    148 +    });
    149 +  });
    150 +});
    151  

```

---

## ðŸ¤– AI Review Checklist

Please review these changes for:

### ðŸ” Code Quality
- [ ] **Linting Compliance**: No unused imports/variables, proper formatting
- [ ] **Type Safety**: Proper typing throughout (TypeScript/Python type hints)
- [ ] **Best Practices**: Framework-specific conventions and patterns
- [ ] **Performance**: Efficient algorithms, proper memoization
- [ ] **Documentation**: Clear comments and function descriptions

### ðŸ› Potential Issues
- [ ] **Runtime Errors**: Type mismatches, null/undefined handling
- [ ] **Logic Bugs**: Incorrect calculations, edge cases
- [ ] **Memory Leaks**: Cleanup in lifecycle methods, event listeners
- [ ] **Error Handling**: Proper try-catch blocks, user feedback
- [ ] **Accessibility**: ARIA labels, keyboard navigation, screen readers

### ðŸ”’ Security & Data
- [ ] **Input Validation**: Sanitization, XSS prevention, SQL injection
- [ ] **Authentication**: Proper access controls and permissions
- [ ] **Privacy**: No sensitive data exposure in logs/client
- [ ] **Dependencies**: Updated packages, vulnerability checks

### ðŸ“± UX/UI
- [ ] **Responsive Design**: Mobile/desktop/tablet compatibility
- [ ] **Loading States**: Proper feedback during async operations
- [ ] **Error Messages**: User-friendly error handling and recovery
- [ ] **Performance**: Fast loading, smooth animations

### ðŸ’¡ Suggestions & Improvements
Please provide specific feedback on:
1. Code organization and structure improvements
2. Performance optimization opportunities
3. Security considerations and hardening
4. Testing coverage and strategies
5. Documentation and maintainability

---
*Generated by AI Visual Code Review v2.0 - Unified Export Script*
*Files processed: 5/5 | Errors: 0 | Generated: 2025-11-08T13:13:07.499Z*
