/**
 * HTMLService - HTML Export Service
 * Handles generation of standalone HTML files with embedded themes and necessary CDNs.
 */

export class HTMLService {
  /**
   * Generate complete HTML document
   *
   * @param {string} contentHtml - The inner HTML of the preview container
   * @param {string} themeName - Current theme name
   * @param {Object} customTheme - Custom theme object (optional)
   * @returns {Promise<Blob>} HTML Blob
   */
  async generateHTML(contentHtml, themeName, customTheme = null) {
    const themeCSS = await this.getThemeCSS(themeName, customTheme);

    const html = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Exported Markdown</title>
    <!-- Math Rendering (KaTeX) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <!-- Mermaid Styles (Basic) -->
    <style>
      .mermaid { display: flex; justify-content: center; margin: 1em 0; }
    </style>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
            line-height: 1.7;
        }

        ${themeCSS}

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }

        /* Base Typography */
        h1 { color: var(--h1-color); font-size: 2.5em; margin: 0.67em 0; border-bottom: 2px solid var(--h1-color); padding-bottom: 0.3em; }
        h2 { color: var(--h2-color); font-size: 2em; margin: 0.75em 0 0.5em 0; }
        h3 { color: var(--h3-color); font-size: 1.5em; margin: 0.83em 0; }
        h4 { color: var(--h4-color); font-size: 1.25em; margin: 1em 0; }
        h5 { color: var(--h5-color); font-size: 1em; margin: 1.33em 0; }
        h6 { color: var(--h6-color); font-size: 0.875em; margin: 1.67em 0; }

        a { color: var(--link-color); text-decoration: none; }
        a:hover { color: var(--link-hover); text-decoration: underline; }

        strong { color: var(--bold-color); font-weight: 700; }
        em { color: var(--italic-color); font-style: italic; }

        /* Code Blocks & Syntax Highlighting */
        code { background-color: var(--code-bg); color: var(--code-text); padding: 2px 6px; border-radius: 4px; font-family: 'Consolas', 'Monaco', monospace; font-size: 0.9em; }
        pre { background-color: var(--code-block-bg) !important; border-radius: 8px; padding: 16px; overflow-x: auto; margin: 1.5em 0; border: 1px solid var(--code-border); }
        pre code { background-color: transparent; color: inherit; padding: 0; }

        /* Prism Tokens (Matching App Theme) */
        .token.comment, .token.prolog, .token.cdata { color: var(--syntax-comment); font-style: italic; }
        .token.punctuation { color: var(--syntax-punctuation); }
        .token.class-name, .token.constant, .token.number, .token.boolean, .token.atrule { color: var(--syntax-number); font-weight: 600; }
        .token.keyword { color: var(--syntax-keyword); font-weight: 700; }
        .token.property, .token.tag, .token.symbol, .token.deleted { color: var(--syntax-property); font-weight: 600; }
        .token.string, .token.char, .token.selector, .token.attr-name { color: var(--syntax-string); }
        .token.function, .token.operator, .token.variable { color: var(--syntax-function); font-weight: 600; }
        .token.url { color: var(--syntax-url); }

        blockquote { border-left: 4px solid var(--blockquote-border); background-color: var(--blockquote-bg); padding: 12px 20px; margin: 1.5em 0; font-style: italic; }

        table { border-collapse: collapse; width: 100%; margin: 1.5em 0; }
        th { background-color: var(--table-header-bg); padding: 12px; text-align: left; border: 1px solid var(--table-border); font-weight: 600; }
        td { padding: 10px 12px; border: 1px solid var(--table-border); }

        hr { border: none; border-top: 2px solid var(--border-color); margin: 2em 0; }
        img { max-width: 100%; height: auto; border-radius: 8px; margin: 1em 0; }

        /* Lists */
        ul, ol { padding-left: 2em; margin: 1em 0; }
        li { margin: 0.5em 0; }
    </style>
</head>
<body>
    ${contentHtml}

    <footer style="margin-top: 40px; border-top: 1px solid var(--border-color); padding-top: 20px; text-align: center; color: var(--text-secondary); font-size: 0.85em;">
        <p style="margin: 0.5em 0;">Generated by <a href="https://prakharmnnit.github.io/markdown-viewer-app/" target="_blank" style="color: inherit; text-decoration: underline;">Markdown Viewer Pro</a></p>
        <p style="margin: 0.5em 0;">Made with ❤️ by Prax Lannister | Follow me on <a href="https://github.com/PrakharMNNIT" target="_blank" style="color: var(--link-color); text-decoration: none;">GitHub</a> & <a href="https://x.com/ByteByByteSrSDE" target="_blank" style="color: var(--link-color); text-decoration: none;">X (Twitter)</a></p>
    </footer>
</body>
</html>`;

    return new Blob([html], { type: 'text/html' });
  }

  /**
   * Helper to retrieve CSS content
   * @private
   */
  async getThemeCSS(themeName, customTheme) {
    if (themeName === 'custom' && customTheme) {
      let css = ':root {\n';
      Object.entries(customTheme).forEach(([prop, val]) => {
        css += `    ${prop}: ${val};\n`;
      });
      css += '}';
      return css;
    }
    const baseUrl = import.meta.env.BASE_URL || '/';
    // Remove leading slash from baseUrl if present to avoid double slash with themes/
    // Actually relative fetch is best.

    try {
      // Use relative path which works best with <base> or current location
      const response = await fetch(`themes/${themeName}.css`);

      let finalResponse = response;
      if (!response.ok) {
        // Fallback to full path construction if relative failed
        const fullPath = `${baseUrl}themes/${themeName}.css`.replace('//', '/');
        finalResponse = await fetch(fullPath);
        if (!finalResponse.ok) throw new Error(`Theme load failed: ${finalResponse.status}`);
      }

      let css = await finalResponse.text();

      // Handle Vite Dev Server response (JS module instead of raw CSS)
      if (css.includes('const __vite__css = "')) {
        const match = css.match(/const __vite__css\s*=\s*"((?:[^"\\]|\\.)*)"/);
        if (match && match[1]) {
          try {
            // Parse JSON string to handle escapes (e.g. \n) correctly
            css = JSON.parse(`"${match[1]}"`);
          } catch (e) {
            console.warn('Failed to parse Vite CSS string', e);
          }
        }
      }
      return css;
    } catch (e) {
      console.error('Failed to load theme CSS', e);
      return '/* Theme Fetch Failed: ' + e.message + ' */';
    }
  }

  downloadHTML(blob, filename = 'exported-markdown.html') {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }
}
