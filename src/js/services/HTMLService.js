/**
 * HTMLService - HTML Export Service
 * Handles generation of standalone HTML files with embedded themes and necessary CDNs.
 */

export class HTMLService {
  /**
   * Generate complete HTML document
   *
   * @param {string} contentHtml - The inner HTML of the preview container
   * @param {string} themeName - Current theme name
   * @param {Object} customTheme - Custom theme object (optional)
   * @returns {Promise<Blob>} HTML Blob
   */
  async generateHTML(contentHtml, themeName, customTheme = null) {
    const themeCSS = await this.getThemeCSS(themeName, customTheme);

    const html = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Exported Markdown</title>
    <!-- Math Rendering (KaTeX) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <!-- Mermaid Styles (Basic) -->
    <style>
      .mermaid { display: flex; justify-content: center; margin: 1em 0; }
    </style>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
            line-height: 1.7;
        }

        ${themeCSS}

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }

        /* Base Typography */
        h1 { color: var(--h1-color); font-size: 2.5em; margin: 0.67em 0; border-bottom: 2px solid var(--h1-color); padding-bottom: 0.3em; }
        h2 { color: var(--h2-color); font-size: 2em; margin: 0.75em 0 0.5em 0; }
        h3 { color: var(--h3-color); font-size: 1.5em; margin: 0.83em 0; }
        h4 { color: var(--h4-color); font-size: 1.25em; margin: 1em 0; }
        h5 { color: var(--h5-color); font-size: 1em; margin: 1.33em 0; }
        h6 { color: var(--h6-color); font-size: 0.875em; margin: 1.67em 0; }

        a { color: var(--link-color); text-decoration: none; }
        a:hover { color: var(--link-hover); text-decoration: underline; }

        strong { color: var(--bold-color); font-weight: 700; }
        em { color: var(--italic-color); font-style: italic; }

        /* Code Blocks & Syntax Highlighting */
        code { background-color: var(--code-bg); color: var(--code-text); padding: 2px 6px; border-radius: 4px; font-family: 'Consolas', 'Monaco', monospace; font-size: 0.9em; }
        pre { background-color: var(--code-block-bg) !important; border-radius: 8px; padding: 16px; overflow-x: auto; margin: 1.5em 0; border: 1px solid var(--code-border); }
        pre code { background-color: transparent; color: inherit; padding: 0; }

        /* Prism Tokens (Matching App Theme) */
        .token.comment, .token.prolog, .token.cdata { color: var(--syntax-comment); font-style: italic; }
        .token.punctuation { color: var(--syntax-punctuation); }
        .token.class-name, .token.constant, .token.number, .token.boolean, .token.atrule { color: var(--syntax-number); font-weight: 600; }
        .token.keyword { color: var(--syntax-keyword); font-weight: 700; }
        .token.property, .token.tag, .token.symbol, .token.deleted { color: var(--syntax-property); font-weight: 600; }
        .token.string, .token.char, .token.selector, .token.attr-name { color: var(--syntax-string); }
        .token.function, .token.operator, .token.variable { color: var(--syntax-function); font-weight: 600; }
        .token.url { color: var(--syntax-url); }

        blockquote { border-left: 4px solid var(--blockquote-border); background-color: var(--blockquote-bg); padding: 12px 20px; margin: 1.5em 0; font-style: italic; }

        table { border-collapse: collapse; width: 100%; margin: 1.5em 0; }
        th { background-color: var(--table-header-bg); padding: 12px; text-align: left; border: 1px solid var(--table-border); font-weight: 600; }
        td { padding: 10px 12px; border: 1px solid var(--table-border); }

        hr { border: none; border-top: 2px solid var(--border-color); margin: 2em 0; }
        img { max-width: 100%; height: auto; border-radius: 8px; margin: 1em 0; }

        /* Lists */
        ul, ol { padding-left: 2em; margin: 1em 0; }
        li { margin: 0.5em 0; }
    </style>
</head>
<body>
    ${contentHtml}

    <footer style="margin-top: 40px; border-top: 1px solid var(--border-color); padding-top: 20px; text-align: center; color: var(--text-secondary); font-size: 0.85em;">
        <p style="margin: 0.5em 0;">Generated by <a href="https://prakharmnnit.github.io/markdown-viewer-app/" target="_blank" style="color: inherit; text-decoration: underline;">Markdown Viewer Pro</a></p>
        <p style="margin: 0.5em 0;">Made with ❤️ by Prax Lannister | Follow me on <a href="https://github.com/PrakharMNNIT" target="_blank" style="color: var(--link-color); text-decoration: none;">GitHub</a> & <a href="https://x.com/ByteByByteSrSDE" target="_blank" style="color: var(--link-color); text-decoration: none;">X (Twitter)</a></p>
    </footer>
</body>
</html>`;

    return new Blob([html], { type: 'text/html' });
  }

  /**
   * Helper to retrieve CSS content
   * @private
   */
  async getThemeCSS(themeName, customTheme) {
    if (themeName === 'custom' && customTheme) {
      let css = ':root {\n';
      Object.entries(customTheme).forEach(([prop, val]) => {
        css += `    ${prop}: ${val};\n`;
      });
      css += '}';
      return css;
    }
    const baseUrl = import.meta.env.BASE_URL || '/';
    // Remove leading slash from baseUrl if present to avoid double slash with themes/
    // Actually relative fetch is best.

    try {
      // Fetch both the specific theme and the global variables which define the tokens
      const requestPromises = [
        fetch(`${baseUrl}themes/${themeName}.css`),
        fetch(`${baseUrl}variables.css`)
      ];

      // If Nebula theme, also fetch the micro-elements styles
      if (themeName.startsWith('nebula-')) {
        requestPromises.push(fetch(`${baseUrl}themes/nebula-elements.css`));
      }

      const responses = await Promise.all(requestPromises);
      const themeRes = responses[0];
      const variablesRes = responses[1];
      const nebulaElementsRes = responses[2]; // Undefined if not nebula

      if (!themeRes.ok) throw new Error(`Failed to load theme: ${themeRes.statusText}`);

      let cssContent = '';

      // Process variables.css
      if (variablesRes.ok) {
        const variablesText = await variablesRes.text();
        cssContent += this.extractCSS(variablesText, baseUrl) + '\n';
      } else {
        console.warn('variables.css could not be loaded for export');
      }

      // Process Nebula Elements if present
      if (nebulaElementsRes && nebulaElementsRes.ok) {
        const nebulaText = await nebulaElementsRes.text();
        cssContent += this.extractCSS(nebulaText, baseUrl) + '\n';
      }

      // Process Theme CSS
      const themeText = await themeRes.text();
      cssContent += this.extractCSS(themeText, baseUrl);

      return cssContent;
    } catch (error) {
      console.warn('Error loading theme CSS:', error);
      // Fallback: minimal styling
      return `
        body { background-color: #fff; color: #333; }
        code { background-color: #f5f5f5; }
        pre { background-color: #f5f5f5; border: 1px solid #ddd; }
        blockquote { border-left: 4px solid #ddd; color: #666; }
        table { border: 1px solid #ddd; }
        th, td { border: 1px solid #ddd; }
      `;
    }
  }

  /**
   * Helper to extract CSS from potential Vite module wrapper or raw text
   */
  extractCSS(text, baseUrl) {
    // Vite dev server serves CSS files as JS modules (import ...)
    // We need to extract the actual CSS string.
    // Typical format: "import ... \n const css = \"...\" ... export default css"
    // OR direct CSS in production build.

    // Simple check for Vite JS module wrapper
    if (text.includes('export default') || text.includes('const css =')) {
      const match = text.match(/const\s+css\s*=\s*"([\s\S]*?)"/);
      if (match && match[1]) {
        // Unescape styling (newlines, etc)
        return match[1].replace(/\\n/g, '\n').replace(/\\"/g, '"');
      }
    }
    return text;
  }

  downloadHTML(blob, filename = 'exported-markdown.html') {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }
}
